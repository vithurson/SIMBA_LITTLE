// See README.md for license details.

package AXI_Unit 

import chisel3._

/**
  * Compute GCD using subtraction method.
  * Subtracts the smaller from the larger until register y is zero.
  * value in register x is then the GCD
  */
class AXI_Unit extends Module {
        val io = IO( new Bundle{
       //writing
        val axi_awaddr  = Output(UInt(32.W))
        val axi_wdata   = Output(UInt(32.W))
        val axi_awready = Input(UInt(1.W))
        val axi_awvalid = Output(UInt(1.W))
        val axi_wvalid  = Output(UInt(1.W))
        val axi_wready  = Input(UInt(1.W))
        /// write response
        val axi_bvalid  = Input(UInt(1.W))
        val axi_bready  = Output(UInt(1.W))
        val axi_bresp   = Input(UInt(2.W))

        // reading

        val axi_araddr  = Output(UInt(32.W))
        val axi_ardata  = Output(UInt(32.W))
        val axi_arready = Input(UInt(1.W))
        val axi_arvalid = Output(UInt(1.W))
        val axi_rvalid  = Output(UInt(1.W))
        val axi_rready  = Input(UInt(1.W))

        // 
        val control     = Input(UInt(2.W))
        val data        = Input(UInt(32.W))
        val data_out    = Output(UInt(32.W))
        val done        = Output(UInt(1.W))
    })
    //write related regs
  val awaddr  = RegInit(UInt(32.W),0.U)
  val wdata   = RegInit(UInt(32.W),0.U)
  val wvalid  = RegInit(UInt(1.W),0.U)
  val awvalid = RegInit(UInt(1.W),0.U)

  //wresp
  val bready = RegInit(UInt(1.W),0.U)
  //read related regs
  val araddr = RegInit(UInt(32.W),0.U)

  /// tight interface
  val odata  = RegInit(UInt(32.W),0.U)
  when( 
  io.data_out := x
  io.outputValid := y === 0.U
}
